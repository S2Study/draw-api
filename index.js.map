{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAw8CC","sourcesContent":["export namespace editor {\n\texport interface Color {\n\t\tr: number;\n\t\tg: number;\n\t\tb: number;\n\t}\n\texport interface DrawEditorProperties {\n\n\t\t/**\n\t\t * 線の色\n\t\t */\n\t\tcolor: Color;\n\n\t\t/**\n\t\t * 線の太さ\n\t\t */\n\t\tthickness: number;\n\n\t\t/**\n\t\t * フォントサイズ\n\t\t */\n\t\tfontSize: number;\n\n\t\t/**\n\t\t * フォントファミリー\n\t\t */\n\t\tfontFamily: string;\n\n\t\t/**\n\t\t * フォントの太さ\n\t\t */\n\t\tfontWeight: number;\n\n\t\t/**\n\t\t * フォントスタイル\n\t\t */\n\t\tfontStyle: string;\n\n\t\t/**\n\t\t * アルファ値\n\t\t */\n\t\talpha: number;\n\n\t\t/**\n\t\t * パスの種別\n\t\t * 0: moveTo\n\t\t * 1: arcTo\n\t\t * 2: quadraticCurveTo\n\t\t * 3: lineTo\n\t\t * 4: bezierCurveTo\n\t\t */\n\t\tpathType: number;\n\t}\n\n\texport interface EventListener<F extends Function> {\n\t\ton(listener: F): void;\n\t\tonce(listener: F): void;\n\t\toff(listener: F): void;\n\t}\n\n\t/**\n\t * プロパティ変更の通知を受け取るリスナーの定義\n\t */\n\texport interface ChangePropertiesListener {\n\t\t( properties: DrawEditorProperties ): void;\n\t}\n\t/**\n\t * プロパティ変更通知に関するアクセスを行うインターフェースの定義\n\t */\n\texport interface ChangeProperties extends EventListener<ChangePropertiesListener> { }\n\n\t/**\n\t * モード変更の通知を受け取るリスナーの定義\n\t */\n\texport interface ModeChangeListener {\n\t\t( mode: number ): void;\n\t}\n\t/**\n\t * モード変更通知に関するアクセスを行うインターフェースの定義\n\t */\n\texport interface ModeChange extends EventListener<ModeChangeListener> { }\n\n\t/**\n\t * レイヤー変更の通知を受け取るリスナーの定義\n\t */\n\texport interface ChangeCurrentLayerListener {\n\t\t( mode: number ): void;\n\t}\n\t/**\n\t * レイヤー変更通知に関するアクセスを行うインターフェースの定義\n\t */\n\texport interface ChangeCurrentLayer extends EventListener<ChangeCurrentLayerListener> { }\n\n\t/**\n\t * キャンバスの変更通知を受け取るリスナーの定義\n\t */\n\texport interface UpdateListener {\n\t\t(): void;\n\t}\n\t/**\n\t * キャンバスの変更通知に関するアクセスを行うインターフェースの定義\n\t */\n\texport interface Update extends EventListener<UpdateListener> { }\n\t/**\n\t * エディタイベントへのアクセスを行うインターフェス\n\t */\n\texport interface DrawEditorEventListeners {\n\n\t\t/**\n\t\t * プロパティ変更通知\n\t\t */\n\t\treadonly changeProperties: ChangeProperties;\n\n\t\t/**\n\t\t * 編集モード編集通知\n\t\t */\n\t\treadonly changeMode: ModeChange;\n\n\t\t/**\n\t\t * 編集レイヤー変更通知\n\t\t */\n\t\treadonly changeCurrentLayer: ChangeCurrentLayer;\n\n\t\t/**\n\t\t * 更新通知\n\t\t */\n\t\treadonly update: Update;\n\t}\n\n\texport interface DrawEditorModeChanger {\n\n\t\t/**\n\t\t * モードチェンジ中\n\t\t */\n\t\treadonly CHANGING: number;\n\n\t\t/**\n\t\t * 消しゴムツールを示す定数\n\t\t */\n\t\treadonly ERASER_MODE: number;\n\n\t\t/**\n\t\t * 塗りツールを示す定数\n\t\t */\n\t\treadonly FILL_MODE: number;\n\n\t\t/**\n\t\t * 線ツールを示す定数\n\t\t */\n\t\treadonly STROKE_MODE: number;\n\n\t\t/**\n\t\t * クリップツールを示す定数\n\t\t */\n\t\treadonly CLIP_MODE: number;\n\n\t\t/**\n\t\t * テキストツールを示す定数\n\t\t */\n\t\treadonly TEXT_MODE: number;\n\n\t\t/**\n\t\t * 手のひらツールを示す定数\n\t\t */\n\t\treadonly HAND_TOOL_MODE: number;\n\n\t\t/**\n\t\t * スポイトツールを示す定数\n\t\t */\n\t\treadonly EYEDROPPER_MODE: number;\n\n\t\t/**\n\t\t * 現在のモードを取得する。\n\t\t */\n\t\tgetMode(): number;\n\n\t\t/**\n\t\t * モード変更\n\t\t */\n\t\tchangeMode(mode: number): Promise<any>;\n\n\t\tisAliveMode(mode: Number): boolean;\n\t}\n\n\texport interface DrawEditorLayers {\n\n\t\t/**\n\t\t * レイヤー数\n\t\t */\n\t\tlayerCount(): Promise<number>;\n\n\t\t/**\n\t\t * レイヤー切り替え\n\t\t * @param index\n\t\t */\n\t\tsetCurrent(index: number): Promise<any>;\n\n\t\t/**\n\t\t * 現在レイヤー\n\t\t */\n\t\tgetCurrent(): Promise<number>;\n\n\t\t/**\n\t\t * 指定レイヤーの表示\n\t\t * @param index\n\t\t */\n\t\tshow(index: number): void;\n\n\t\t/**\n\t\t * 指定レイヤーの非表示\n\t\t * @param index\n\t\t */\n\t\thide(index: number): void;\n\n\t\t/**\n\t\t * レイヤー全非表示\n\t\t */\n\t\thideAll(): void;\n\n\t\t/**\n\t\t * レイヤーの全表示\n\t\t */\n\t\tshowAll(): void;\n\n\t\t/**\n\t\t * レイヤーの削除\n\t\t * @param index\n\t\t */\n\t\tremove(index: number): Promise<any>;\n\n\t\t/**\n\t\t *  レイヤーの追加\n\t\t */\n\t\taddLayer(): Promise<any>;\n\n\t\t/**\n\t\t * レイヤーの順序移動\n\t\t * @param index\n\t\t */\n\t\tmoveTo(index: number): Promise<any>;\n\t}\n\n\texport interface DrawEditorCanvas {\n\n\t\t/**\n\t\t * MouseDownもしくはTouchStartイベントを通知する。\n\t\t * Canvasの左上を0,0とした座標を設定する。\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\ttouchStart(x: number, y: number): void;\n\n\t\t/**\n\t\t * ドラッグもしくはTouchMoveイベントを通知する。\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\ttouchMove(x: number, y: number): void;\n\n\t\t/**\n\t\t * MouseUpもしくはTouchEndイベントを取得する。\n\t\t * Canvasの左上を0,0とした座標を設定する。\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\ttouchEnd(x: number, y: number): void;\n\n\t\t/**\n\t\t * テキストを設定する。\n\t\t * @param text\n\t\t */\n\t\tsetText(text: string): void;\n\n\t\t/**\n\t\t * 座標設定の履歴を元に戻す。\n\t\t */\n\t\tbackward(): void;\n\t}\n\n\texport interface DrawEditor {\n\n\t\t/**\n\t\t * Canvasの幅\n\t\t */\n\t\tgetWidth(): number;\n\n\t\t/**\n\t\t * Canvasの高さ\n\t\t */\n\t\tgetHeight(): number;\n\n\t\t/**\n\t\t * Undo\n\t\t */\n\t\tundo(): Promise<any>;\n\n\t\t/**\n\t\t * Undoが可能かどうか\n\t\t */\n\t\tcanUndo(): boolean;\n\n\t\t/**\n\t\t * Redo\n\t\t */\n\t\tredo(): Promise<any>;\n\n\t\t/**\n\t\t * Redoが可能かどうか\n\t\t */\n\t\tcanRedo(): boolean;\n\n\t\t/**\n\t\t * 明示的に再描画する。\n\t\t */\n\t\treRender(): void;\n\n\t\t/**\n\t\t * イベント受付、描画を停止する\n\t\t */\n\t\tstop(): void;\n\n\t\t/**\n\t\t * イベント受付、描画を開始する。\n\t\t */\n\t\tstart(): void;\n\n\t\t/**\n\t\t * メインキャンバス\n\t\t */\n\t\treadonly canvas: DrawEditorCanvas;\n\n\t\t/**\n\t\t * 設定値\n\t\t */\n\t\treadonly properties: DrawEditorProperties;\n\n\t\t/**\n\t\t * レイヤー\n\t\t */\n\t\treadonly layers: DrawEditorLayers;\n\n\t\t/**\n\t\t * モードチェンジャー\n\t\t */\n\t\treadonly mode: DrawEditorModeChanger;\n\n\t\t/**\n\t\t * イベントリスナー\n\t\t */\n\t\treadonly events: DrawEditorEventListeners;\n\t}\n}\n\n\nexport namespace history {\n\timport Message = structures.Message;\n\timport Layer = structures.Layer;\n\timport Transform = structures.Transform;\n\timport Clip = structures.Clip;\n\timport Draw = structures.Draw;\n\texport interface DrawHistory {\n\n\t\t/**\n\t\t * 履歴番号の一覧を取得する。\n\t\t */\n\t\tgetHistoryNumbers(): number[];\n\n\t\t/**\n\t\t * 現在の履歴番号を取得する。\n\t\t */\n\t\tgetNowHistoryNumber(): number;\n\n\t\t/**\n\t\t * 最終履歴番号を取得する。\n\t\t */\n\t\tgetLastHistoryNumber(): number;\n\n\t\t/**\n\t\t * 初回の履歴番号を取得する。存在しない場合は-1が返る。\n\t\t */\n\t\tgetFirstHistoryNumber(): number;\n\n\t\t/**\n\t\t * 指定された範囲の履歴を取得する。\n\t\t * @param from\n\t\t * @param to\n\t\t */\n\t\tgetMoments(from: number, to: number, ignoreLocal?: boolean): DrawMoment[];\n\n\t\t/**\n\t\t * 履歴を計算し、現在のDrawMessageを生成する。\n\t\t */\n\t\tgenerateMessage(ignoreLocal?: boolean): Message;\n\n\t\t/**\n\t\t * 指定されたhistoryNumber時点のレイヤーリストを取得する。\n\t\t * @param historyNumber\n\t\t */\n\t\tgetLayers(historyNumber?: number, ignoreLocal?: boolean): string[];\n\n\t\t/**\n\t\t * 更新イベントを待ち受けるリスナーを設定する。\n\t\t * 指定されたcallBackは一度のみ呼び出される。\n\t\t * 継続してイベントを受け取りたい場合は設定側で都度このメソッドを発行する必要がある。\n\t\t * @param callback\n\t\t */\n\t\tawaitUpdate(callback: (historyNumber: number) => void): void;\n\n\t\t/**\n\t\t * 有効な履歴かどうか\n\t\t * @param historyNumber\n\t\t */\n\t\tisAvailable(historyNumber?: number): boolean;\n\n\t\t/**\n\t\t * 編集セッションを開始する。\n\t\t * @param noWait 現在ロックしている編集セッションを強制的に解除するかどうか。\n\t\t */\n\t\tlock(noWait?: boolean): Promise<DrawHistoryEditSession>;\n\t}\n\n\texport interface NumberGenerator {\n\t\tgenerateNumber(): number;\n\t}\n\texport interface KeyGenerator {\n\t\tgenerateKey(): string;\n\t}\n\n\texport interface DrawHistoryEditSession {\n\n\t\t/**\n\t\t * セッションが有効かどうか\n\t\t */\n\t\tisAlive(): boolean;\n\n\t\t/**\n\t\t * 履歴番号を設定する。<br />\n\t\t * 現在の履歴番号に指定値の履歴番号が存在しない場合は指定値以下で最も大きい履歴番号が設定される。\n\t\t * 以降の更新メソッドが発生した際、指定値より大きい履歴が削除される。\n\t\t * @param historyNumber\n\t\t * @param clearFuture 指定されたhistoryNumberより先の履歴を削除するかどうか。デフォルト値はfalse\n\t\t */\n\t\tsetHistoryNumberNow(historyNumber: number, clearFuture?: boolean): number;\n\n\t\t/**\n\t\t * 履歴をクリアする。\n\t\t */\n\t\tclear(): void;\n\n\t\t/**\n\t\t * 新しいレイヤーを追加する。\n\t\t * @param layer\n\t\t * @param isLocal\n\t\t */\n\t\taddLayer(layer: Layer, isLocal?: boolean): DrawMoment;\n\n\t\t/**\n\t\t * 指定されたIDのレイヤーを削除する。\n\t\t * @param layerId\n\t\t */\n\t\tremoveLayer(layerId: string): void;\n\n\t\t/**\n\t\t * 編集履歴を積み上げる。\n\t\t * 結果はcommit時に反映する。\n\t\t */\n\t\taddMoment(): DrawMomentBuilder;\n\n\t\t/**\n\t\t * 編集セッションを解放する。\n\t\t */\n\t\trelease(): void;\n\t}\n\n\texport interface DrawMomentBuilder {\n\n\t\tputLayerMoment(key: string): DrawLayerMomentBuilder;\n\n\t\tsetSequence(sequence: string[]): DrawMomentBuilder;\n\n\t\tcommit(): DrawMoment;\n\t}\n\n\t/**\n\t * 履歴アイテム\n\t */\n\texport interface DrawMoment {\n\n\t\t/**\n\t\t * 履歴番号\n\t\t */\n\t\tgetHistoryNumber(): number;\n\n\t\t/**\n\t\t * CanvasId毎の変更マッピング。\n\t\t */\n\t\tgetKeys(): string[];\n\t\tgetLayerMoment(key: string): DrawLayerMoment;\n\n\t\t/**\n\t\t * Canvasの表示順　背面であるほど小さい添字。\n\t\t * 更新される毎に全件分設定され、ここにないCanvasは削除扱いとする。\n\t\t */\n\t\tgetSequence(): string[];\n\t}\n\n\texport interface DrawLayerMomentBuilder {\n\n\t\tsetTransForm(transform: Transform): DrawLayerMomentBuilder;\n\n\t\tsetClip(clip: Clip): DrawLayerMomentBuilder;\n\n\t\taddDraw(draw: Draw): DrawLayerMomentBuilder;\n\n\t\taddDraws(draw: Draw[]): DrawLayerMomentBuilder;\n\n\t\tcommit(): DrawMomentBuilder;\n\t}\n\n\t/**\n\t * Canvas毎の履歴アイテム\n\t */\n\texport interface DrawLayerMoment {\n\n\t\t/**\n\t\t * CanvasId\n\t\t */\n\t\tgetCanvasId(): string;\n\n\t\t/**\n\t\t * Canvas全体の変形成分。\n\t\t * 変更がある場合は毎回全体上書き。\n\t\t */\n\t\tgetTransform(): Transform;\n\n\t\t/**\n\t\t * Canvasの切り抜き。\n\t\t * 変更がある場合は毎回全体上書き。<br />\n\t\t * 切り抜きしたくない場合はpathの値がnullな空のClipを設定する。\n\t\t */\n\t\tgetClip(): Clip;\n\n\t\t/**\n\t\t * 書き込み履歴（追加分のみ）\n\t\t */\n\t\tgetDraws(): Draw[];\n\t}\n}\n\nexport namespace renderer {\n\timport Draw = structures.Draw;\n\timport Clip = structures.Clip;\n\timport Transform = structures.Transform;\n\texport interface DrawchatRenderer {\n\n\t\twidth: number;\n\t\theight: number;\n\n\t\t/**\n\t\t * レイヤーの数を取得します。\n\t\t */\n\t\tsize(): number;\n\n\t\t/**\n\t\t * レイヤーの前面＞背面の順序を変更する。\n\t\t * @param order 元の添字を格納したリスト。リストの添字順にソートされる。\n\t\t */\n\t\tsortLayer(order: number[]): void;\n\n\t\t/**\n\t\t * 指定された添字のレイヤーを削除する。\n\t\t * @param index\n\t\t */\n\t\tremoveLayer(index: number): void;\n\n\t\t/**\n\t\t * レイヤーを新規に追加する。<br />\n\t\t * 追加したレイヤーの添字\n\t\t */\n\t\taddLayer(): number;\n\n\t\t/**\n\t\t * 指定された添字のレイヤーを一から描画する。\n\t\t * @param index 対象レイヤーの添字\n\t\t * @param draws 差分描画内容\n\t\t * @param transform 変形成分\n\t\t * @param clip くりぬきの指定\n\t\t */\n\t\trender(\n\t\t\tindex: number,\n\t\t\tdraws: Draw[],\n\t\t\ttransform?: Transform,\n\t\t\tclip?: Clip): void;\n\n\t\t/**\n\t\t * 指定された添字のレイヤーに対し、差分を描画する。\n\t\t * @param index 対象レイヤーの添字\n\t\t * @param draws 差分描画内容\n\t\t */\n\t\trenderDiff(\n\t\t\tindex: number,\n\t\t\tdraws: Draw[]\n\t\t): void;\n\n\t\t/**\n\t\t * 描画内容を全てクリアする。\n\t\t */\n\t\tclear(): void;\n\n\t\t/**\n\t\t * 画像をbase64化したデータを取得する。\n\t\t */\n\t\tcreateImageDataURI(): string;\n\n\t\t/**\n\t\t * 指定された添字のレイヤーを表示状態に設定する。\n\t\t * 引数が指定されていない場合は全件表示。\n\t\t * @param target\n\t\t */\n\t\tshow(target?: number[]): void;\n\n\t\t/**\n\t\t * 指定された添字のレイヤーを非表示状態に設定する。\n\t\t * 引数が指定されていない場合は全件非表示。\n\t\t * @param target\n\t\t */\n\t\thide(target?: number[]): void;\n\n\t\t/**\n\t\t * 指定されたピクセル座標の色成分を取得する。\n\t\t * r,g,b,aの配列を返す。\n\t\t */\n\t\tgetPixelColor(\n\t\t\tx: number,\n\t\t\ty: number,\n\t\t\tlayerIndex: number): number[];\n\t}\n}\nexport namespace structures {\n\texport interface Messages {\n\t\tmessage: Message[];\n\t}\n\texport interface Message {\n\t\tid?: string;\n\t\tseq?: number;\n\t\tauthor?: string;\n\t\ttime?: number;\n\t\ttitle?: string;\n\t\tcanvas?: Layer[];\n\t}\n\texport interface Layer {\n\t\ttransform?: Transform;\n\t\tclip?: Clip;\n\t\tdraws: Draw[];\n\t}\n\texport interface Transform {\n\t\ta?: number;\n\t\tb?: number;\n\t\tc?: number;\n\t\td?: number;\n\t\tx?: number;\n\t\ty?: number;\n\t}\n\texport interface Clip {\n\t\ttransform?: Transform;\n\t\tpath: PathItem[];\n\t}\n\texport interface PathItem {\n\t\ttype: number;\n\t}\n\texport interface MoveTo extends PathItem {\n\t\tx: number;\n\t\ty: number;\n\t}\n\texport interface ArcTo extends PathItem {\n\t\tx1: number;\n\t\ty1: number;\n\t\tx2: number;\n\t\ty2: number;\n\t\tradius: number;\n\t}\n\texport interface LineTo extends PathItem {\n\t\tx: number;\n\t\ty: number;\n\t}\n\texport interface QuadraticCurveTo extends PathItem {\n\t\tcpx: number;\n\t\tcpy: number;\n\t\tx: number;\n\t\ty: number;\n\t}\n\texport interface BezierCurveTo extends PathItem {\n\t\tcpx1: number;\n\t\tcpy1: number;\n\t\tcpx2: number;\n\t\tcpy2: number;\n\t\tx: number;\n\t\ty: number;\n\t}\n\n\texport interface Draw {\n\t\ttransform?: Transform;\n\t\tcompositeOperation: number;\n\t}\n\texport interface GraphicsDraw extends Draw {\n\t\tgraphics: Graphic[];\n\t}\n\texport interface Graphic {\n\t\tfill?: Fill;\n\t\tstroke?: Stroke;\n\t\tpath: PathItem[];\n\t}\n\n\texport interface Fill {\n\t\tcolor?: string;\n\t\tlinerGradient?: LinerGradient;\n\t\tradialGradient?: RadialGradient;\n\t}\n\texport interface LinerGradient {\n\t\tx0: number;\n\t\ty0: number;\n\t\tx1: number;\n\t\ty1: number;\n\t\tcolorStops?: ColorStop[];\n\t}\n\texport interface ColorStop {\n\t\toffset: number;\n\t\tcolor: string;\n\t}\n\texport interface RadialGradient extends Fill {\n\t\tx0: number;\n\t\ty0: number;\n\t\tr0: number;\n\t\tx1: number;\n\t\ty1: number;\n\t\tr1: number;\n\t\tcolorStops?: ColorStop[];\n\t}\n\texport interface Stroke {\n\t\tfillStyle?: Fill;\n\t\tdash?: Dash;\n\t\tstyle?: StrokeStyle;\n\t}\n\texport interface Dash {\n\t\tsegments?: number[];\n\t\toffset?: number;\n\t}\n\texport interface StrokeStyle {\n\t\tthickness?: number;\n\t\tcaps?: number;\n\t\tjoints?: number;\n\t\tmiterLimit?: number;\n\t\tignoreScale?: number;\n\t}\n\texport interface TextDraw extends Draw {\n\t\ttext: Text;\n\t}\n\texport interface Text {\n\t\tx: number;\n\t\ty: number;\n\t\tfontFamily?: string;\n\t\tsize?: number;\n\t\tweight?: number;\n\t\tstyle?: number;\n\t\tfill?: Fill;\n\t\tstroke?: Stroke;\n\t\talign?: string;\n\t\tbaseline?: string;\n\t\ttext: string;\n\t}\n}\n\nexport namespace updater {\n\timport Transform = structures.Transform;\n\timport ColorStop = structures.ColorStop;\n\texport interface DrawchatUpdater {\n\n\t\t/**\n\t\t * レイヤーを追加し、追加されたレイヤーのIDを取得する。\n\t\t */\n\t\taddLayer(): Promise<string>;\n\n\t\t/**\n\t\t * 指定されたレイヤーを削除する。\n\t\t * @param layerId\n\t\t */\n\t\tremoveLayer(layerId: string): Promise<any>;\n\n\t\t/**\n\t\t * レイヤーIDのリストを取得する。\n\t\t */\n\t\tgetLayers(): string[];\n\n\t\t/**\n\t\t * 変形トランザクションを開始する。\n\t\t * @param layerId\n\t\t * @param commit 直前の未コミットトランザクションが存在する場合、コミットするかキャンセルするかどうか。\n\t\t * デフォルト値はtrue\n\t\t */\n\t\tbeginTransform(layerId: string, commit?: boolean): Promise<TransformTransaction>;\n\n\t\t/**\n\t\t * 切り抜きトランザクションを開始する。\n\t\t * @param layerId\n\t\t * @param commit 直前の未コミットトランザクションが存在する場合、コミットするかキャンセルするかどうか。\n\t\t * デフォルト値はtrue\n\t\t */\n\t\tbeginClip(layerId: string, commit?: boolean): Promise<ClipTransaction>;\n\n\t\t/**\n\t\t * 描画トランザクションを開始する。\n\t\t * @param layerId\n\t\t * @param commit 直前の未コミットトランザクションが存在する場合、コミットするかキャンセルするかどうか。\n\t\t * デフォルト値はtrue\n\t\t */\n\t\tbeginPath(layerId: string, commit?: boolean): Promise<DrawPathTransaction>;\n\n\t\t/**\n\t\t * テキストトランザクションを開始する。\n\t\t * @param layerId\n\t\t * @param commit 直前の未コミットトランザクションが存在する場合、コミットするかキャンセルするかどうか。\n\t\t * デフォルト値はtrue\n\t\t */\n\t\tbeginText(layerId: string, commit?: boolean): Promise<TextTransaction>;\n\n\t\t/**\n\t\t * 表示順変更トランザクションを開始する。\n\t\t * @param commit 直前の未コミットトランザクションが存在する場合、コミットするかキャンセルするかどうか。\n\t\t * デフォルト値はtrue\n\t\t */\n\t\tbeginChangeSequence(commit?: boolean): Promise<ChangeSequenceTransaction>;\n\n\t\t/**\n\t\t * Undoが可能かどうかの判定\n\t\t */\n\t\tcanUndo(): boolean;\n\n\t\t/**\n\t\t * Redoが可能かどうかの判定\n\t\t */\n\t\tcanRedo(): boolean;\n\n\t\t/**\n\t\t * 一つ前の状態に戻す。\n\t\t */\n\t\tundo(): Promise<any>;\n\n\t\t/**\n\t\t * 戻した変更を進める。\n\t\t */\n\t\tredo(): Promise<any>;\n\t}\n\n\t/**\n\t * トランザクション\n\t */\n\texport interface DrawTransaction {\n\n\t\t/**\n\t\t * トランザクションが有効かどうか\n\t\t */\n\t\tisAlive(): boolean;\n\n\t\t/**\n\t\t * 変更内容をキャンセルする。\n\t\t */\n\t\tcancel(duration?: boolean): void;\n\n\t\t/**\n\t\t * 変更内容を確定する。\n\t\t */\n\t\tcommit(duration?: boolean): void;\n\n\t\t/**\n\t\t * 直前までの変更を履歴に反映する。\n\t\t */\n\t\tflush(): void;\n\n\t\t/**\n\t\t * savePointを設定する。\n\t\t */\n\t\tsetSavePoint(): void;\n\n\t\t/**\n\t\t * savePointに戻す。\n\t\t */\n\t\trestoreSavePoint(): void;\n\t}\n\n\t/**\n\t * 変形トランザクション\n\t */\n\texport interface TransformTransaction extends DrawTransaction {\n\n\t\t/**\n\t\t * 変形成分を設定\n\t\t * @param transform\n\t\t */\n\t\tsetMatrix(transform: Transform): TransformTransaction;\n\n\t\t/**\n\t\t * 変換マトリックスに並行移動を加えます。\n\t\t * @param tx\n\t\t * @param ty\n\t\t * @returns {Transform}\n\t\t */\n\t\ttranslate(tx: number, ty: number): TransformTransaction;\n\n\t\t/**\n\t\t * 変換マトリックスにX軸方向への変倍を加えます。\n\t\t * @param scaleX\n\t\t * @returns {Transform}\n\t\t */\n\t\tscaleX(scaleX: number): TransformTransaction;\n\n\t\t/**\n\t\t * 変換マトリックスにY軸方向への変倍を加えます。\n\t\t * @param scaleY\n\t\t * @returns {Transform}\n\t\t */\n\t\tscaleY(scaleY: number): TransformTransaction;\n\t\t/**\n\t\t * 変換マトリックスに変倍を加えます。\n\t\t * @param scaleX\n\t\t * @param scaleY\n\t\t * @returns {Transform}\n\t\t */\n\t\tscale(scaleX: number, scaleY: number): TransformTransaction;\n\n\t\t/**\n\t\t * 変換マトリックスに回転成分を加えます。\n\t\t * @param rad\n\t\t * @returns {Transform}\n\t\t */\n\t\trotate(transform: Transform, rad: number): TransformTransaction;\n\n\t\t/**\n\t\t * マトリックスにX軸方向へのゆがみ成分を加えます。\n\t\t * @param radX\n\t\t * @returns {Transform}\n\t\t */\n\t\tskewX(transform: Transform, radX: number): TransformTransaction;\n\n\t\t/**\n\t\t * マトリックスにY軸方向へのゆがみ成分を加えます。\n\t\t * @param radY\n\t\t * @returns {Transform}\n\t\t */\n\t\tskewY(transform: Transform, radY: number): TransformTransaction;\n\n\t\t/**\n\t\t * マトリックスにゆがみ成分を加えます。\n\t\t * @param radX\n\t\t * @param radY\n\t\t * @returns {Transform}\n\t\t */\n\t\tskew(radX: number, radY: number): TransformTransaction;\n\n\t\t/**\n\t\t * Matrixを結合します。\n\t\t * @param transform\n\t\t * @returns {Transform}\n\t\t */\n\t\tconcat(transform: Transform): TransformTransaction;\n\t}\n\n\t/**\n\t * 線描画トランザクション\n\t */\n\texport interface PathTransaction extends DrawTransaction {\n\n\t\t/**\n\t\t * 現在の起点を移動する。何もしなければ最初は0,0\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tmoveTo(\n\t\t\tx: number,\n\t\t\ty: number): PathTransaction;\n\n\t\t/**\n\t\t * 円弧を描画する。\n\t\t * @param x1\n\t\t * @param y1\n\t\t * @param x2\n\t\t * @param y2\n\t\t * @param radius\n\t\t */\n\t\tarcTo(\n\t\t\tx1: number,\n\t\t\ty1: number,\n\t\t\tx2: number,\n\t\t\ty2: number,\n\t\t\tradius: number): PathTransaction;\n\n\t\t/**\n\t\t * 直線を描画する。\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tlineTo(\n\t\t\tx: number,\n\t\t\ty: number): PathTransaction;\n\n\t\t/**\n\t\t * 2次ベジェ曲線を描画する。\n\t\t * @param cpx\n\t\t * @param cpy\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tquadraticCurveTo (\n\t\t\tcpx: number,\n\t\t\tcpy: number,\n\t\t\tx: number,\n\t\t\ty: number): PathTransaction;\n\n\t\t/**\n\t\t * 3次ベジェ曲線を描画する。\n\t\t * @param cpx1\n\t\t * @param cpy1\n\t\t * @param cpx2\n\t\t * @param cpy2\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tbezierCurveTo (\n\t\t\tcpx1: number,\n\t\t\tcpy1: number,\n\t\t\tcpx2: number,\n\t\t\tcpy2: number,\n\t\t\tx: number,\n\t\t\ty: number): PathTransaction;\n\t}\n\n\t/**\n\t * 線描画トランザクション\n\t */\n\texport interface ClipTransaction extends PathTransaction {\n\n\t\t/**\n\t\t * 現在の起点を移動する。何もしなければ最初は0,0\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tmoveTo(\n\t\t\tx: number,\n\t\t\ty: number): ClipTransaction;\n\n\t\t/**\n\t\t * 円弧を描画する。\n\t\t * @param x1\n\t\t * @param y1\n\t\t * @param x2\n\t\t * @param y2\n\t\t * @param radius\n\t\t */\n\t\tarcTo(\n\t\t\tx1: number,\n\t\t\ty1: number,\n\t\t\tx2: number,\n\t\t\ty2: number,\n\t\t\tradius: number): ClipTransaction;\n\n\t\t/**\n\t\t * 直線を描画する。\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tlineTo(\n\t\t\tx: number,\n\t\t\ty: number): ClipTransaction;\n\n\t\t/**\n\t\t * 2次ベジェ曲線を描画する。\n\t\t * @param cpx\n\t\t * @param cpy\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tquadraticCurveTo (\n\t\t\tcpx: number,\n\t\t\tcpy: number,\n\t\t\tx: number,\n\t\t\ty: number): ClipTransaction;\n\n\t\t/**\n\t\t * 3次ベジェ曲線を描画する。\n\t\t * @param cpx1\n\t\t * @param cpy1\n\t\t * @param cpx2\n\t\t * @param cpy2\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tbezierCurveTo (\n\t\t\tcpx1: number,\n\t\t\tcpy1: number,\n\t\t\tcpx2: number,\n\t\t\tcpy2: number,\n\t\t\tx: number,\n\t\t\ty: number): ClipTransaction;\n\n\t\t/**\n\t\t * 直前までの変更を履歴に反映する。\n\t\t */\n\t\tflush(): void;\n\n\t}\n\n\t/**\n\t * 線描画トランザクション\n\t */\n\texport interface DrawPathTransaction extends PathTransaction {\n\t\t/**\n\t\t * 既存の描画内容との合成方法を指定する。\n\t\t * 0:source-over 両方のイメージの領域が描画される。重なった部分は新規イメージとなる。（初期値）<br />\n\t\t * 1:source-atop 現在イメージの領域のみが描画される。重なった部分は新規イメージとなる。<br />\n\t\t * 2:source-in 重なった領域のみが描画される。重なった部分は新規イメージとなる。<br />\n\t\t * 3:source-out 新規イメージの領域のみが描画される。重なった部分は描画されない。<br />\n\t\t * 4:destination-atop 新規イメージの領域のみが描画される。重なった部分は現在イメージとなる。<br />\n\t\t * 5:destination-in 重なった領域のみが描画される。重なった部分は現在イメージとなる。<br />\n\t\t * 6:destination-out 現在イメージの領域のみが描画される。重なった部分は描画されない。<br />\n\t\t * 7:destination-over 両方のイメージの領域が描画される。重なった部分は現在イメージとなる。<br />\n\t\t * 8:lighter 両方のイメージの領域が描画される。重なった部分は混色して描画される。<br />\n\t\t * 9:copy 新規イメージの領域のみが描画される。重なった部分は新規イメージとなる。<br />\n\t\t * 10:xor 両方のイメージの領域が描画される。重なった部分は描画されない。<br />\n\t\t * @param compositeOperation\n\t\t */\n\t\tsetCompositeOperation(compositeOperation: number): DrawPathTransaction;\n\n\t\t/**\n\t\t * 塗りの色を設定する。\n\t\t * 線形・円形グラデーション・ベタ塗りは混在は混在しない。\n\t\t * @param color\n\t\t */\n\t\tsetFill(color: string): DrawPathTransaction;\n\n\t\t/**\n\t\t * 線形グラデーションを設定する。\n\t\t * 線形・円形グラデーション・ベタ塗りは混在は混在しない。\n\t\t * @param x0\n\t\t * @param y0\n\t\t * @param x1\n\t\t * @param y1\n\t\t * @param colorStops\n\t\t */\n\t\tsetFillLinerGradient(\n\t\t\tx0: number,\n\t\t\ty0: number,\n\t\t\tx1: number,\n\t\t\ty1: number,\n\t\t\tcolorStops?: ColorStop[]): DrawPathTransaction;\n\n\t\t/**\n\t\t * 円形グラデーションを設定する。\n\t\t * 線形・円形グラデーション・ベタ塗りは混在は混在しない。\n\t\t * @param x0\n\t\t * @param y0\n\t\t * @param r0\n\t\t * @param x1\n\t\t * @param y1\n\t\t * @param r1\n\t\t * @param colorStops\n\t\t */\n\t\tsetFillRadialGradient(\n\t\t\tx0: number,\n\t\t\ty0: number,\n\t\t\tr0: number,\n\t\t\tx1: number,\n\t\t\ty1: number,\n\t\t\tr1: number,\n\t\t\tcolorStops?: ColorStop[]): DrawPathTransaction;\n\n\t\t/**\n\t\t * 線の色を設定する。\n\t\t * @param color\n\t\t */\n\t\tsetStrokeColor(color: string): DrawPathTransaction;\n\n\t\t/**\n\t\t * 破線を設定。引数がいずれもnullの場合は破線なし。\n\t\t * @param segments\n\t\t * @param offset\n\t\t */\n\t\tsetStrokeDash(\n\t\t\tsegments?: number[],\n\t\t\toffset?: number): DrawPathTransaction;\n\n\t\t/**\n\t\t * 線スタイルを設定。\n\t\t * @param thickness 太さ\n\t\t * @param caps 線端の形\n\t\t * @param joints 接点の形\n\t\t * @param miterLimit\n\t\t * @param ignoreScale\n\t\t */\n\t\tsetStrokeStyle(\n\t\t\tthickness?: number,\n\t\t\tcaps?: number,\n\t\t\tjoints?: number,\n\t\t\tmiterLimit?: number,\n\t\t\tignoreScale?: number): DrawPathTransaction;\n\n\t\t/**\n\t\t * 現在の起点を移動する。何もしなければ最初は0,0\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tmoveTo(\n\t\t\tx: number,\n\t\t\ty: number): DrawPathTransaction;\n\n\t\t/**\n\t\t * 円弧を描画する。\n\t\t * @param x1\n\t\t * @param y1\n\t\t * @param x2\n\t\t * @param y2\n\t\t * @param radius\n\t\t */\n\t\tarcTo(\n\t\t\tx1: number,\n\t\t\ty1: number,\n\t\t\tx2: number,\n\t\t\ty2: number,\n\t\t\tradius: number): DrawPathTransaction;\n\n\t\t/**\n\t\t * 直線を描画する。\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tlineTo(\n\t\t\tx: number,\n\t\t\ty: number): DrawPathTransaction;\n\n\t\t/**\n\t\t * 2次ベジェ曲線を描画する。\n\t\t * @param cpx\n\t\t * @param cpy\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tquadraticCurveTo (\n\t\t\tcpx: number,\n\t\t\tcpy: number,\n\t\t\tx: number,\n\t\t\ty: number): DrawPathTransaction;\n\n\t\t/**\n\t\t * 3次ベジェ曲線を描画する。\n\t\t * @param cpx1\n\t\t * @param cpy1\n\t\t * @param cpx2\n\t\t * @param cpy2\n\t\t * @param x\n\t\t * @param y\n\t\t */\n\t\tbezierCurveTo (\n\t\t\tcpx1: number,\n\t\t\tcpy1: number,\n\t\t\tcpx2: number,\n\t\t\tcpy2: number,\n\t\t\tx: number,\n\t\t\ty: number): DrawPathTransaction;\n\t}\n\n\t/**\n\t * 全面、背面入れ替えのトランザクション\n\t */\n\texport interface ChangeSequenceTransaction extends DrawTransaction {\n\n\t\t/**\n\t\t * 指定されたレイヤーを最前面へ移動する。\n\t\t * @param layerId\n\t\t */\n\t\ttoFirst(layerId: string): ChangeSequenceTransaction;\n\n\t\t/**\n\t\t * 指定されたレイヤーを前面へ移動する。\n\t\t * @param layerId\n\t\t */\n\t\ttoPrev(layerId: string): ChangeSequenceTransaction;\n\t\t/**\n\t\t * 指定されたレイヤーを背面へ移動する。\n\t\t * @param layerId\n\t\t */\n\t\ttoBack(layerId: string): ChangeSequenceTransaction;\n\t\t/**\n\t\t * 指定されたレイヤーを最背面へ移動する。\n\t\t * @param layerId\n\t\t */\n\t\ttoLast(layerId: string): ChangeSequenceTransaction;\n\t\t/**\n\t\t * レイヤーの順序を移動する。\n\t\t * @param layerId\n\t\t * @param index\n\t\t */\n\t\ttoMove(layerId: string, index: number): ChangeSequenceTransaction;\n\t}\n\n\t/**\n\t * テキスト編集トランザクション\n\t */\n\texport interface TextTransaction extends DrawTransaction {\n\n\t\t/**\n\t\t * 既存の描画内容との合成方法を指定する。\n\t\t * 0:source-over 両方のイメージの領域が描画される。重なった部分は新規イメージとなる。（初期値）<br />\n\t\t * 1:source-atop 現在イメージの領域のみが描画される。重なった部分は新規イメージとなる。<br />\n\t\t * 2:source-in 重なった領域のみが描画される。重なった部分は新規イメージとなる。<br />\n\t\t * 3:source-out 新規イメージの領域のみが描画される。重なった部分は描画されない。<br />\n\t\t * 4:destination-atop 新規イメージの領域のみが描画される。重なった部分は現在イメージとなる。<br />\n\t\t * 5:destination-in 重なった領域のみが描画される。重なった部分は現在イメージとなる。<br />\n\t\t * 6:destination-out 現在イメージの領域のみが描画される。重なった部分は描画されない。<br />\n\t\t * 7:destination-over 両方のイメージの領域が描画される。重なった部分は現在イメージとなる。<br />\n\t\t * 8:lighter 両方のイメージの領域が描画される。重なった部分は混色して描画される。<br />\n\t\t * 9:copy 新規イメージの領域のみが描画される。重なった部分は新規イメージとなる。<br />\n\t\t * 10:xor 両方のイメージの領域が描画される。重なった部分は描画されない。<br />\n\t\t * @param compositeOperation\n\t\t */\n\t\tsetCompositeOperation(compositeOperation: number): TextTransaction;\n\n\t\tsetPosition(x: number, y: number): TextTransaction;\n\n\t\t/**\n\t\t * テキストの塗りを設定する。\n\t\t * 線形・円形グラデーション・ベタ塗りは混在は混在しない。\n\t\t * @param color\n\t\t */\n\t\tsetFill(color: string): TextTransaction;\n\t\t/**\n\t\t * テキストの線形グラデーションを設定する。\n\t\t * 線形・円形グラデーション・ベタ塗りは混在は混在しない。\n\t\t * @param x0\n\t\t * @param y0\n\t\t * @param x1\n\t\t * @param y1\n\t\t * @param colorStops\n\t\t */\n\t\tsetFillLinerGradient(\n\t\t\tx0: number,\n\t\t\ty0: number,\n\t\t\tx1: number,\n\t\t\ty1: number,\n\t\t\tcolorStops?: ColorStop[]): TextTransaction;\n\t\t/**\n\t\t * テキストの円形グラデーションを設定する。\n\t\t * 線形・円形グラデーション・ベタ塗りは混在は混在しない。\n\t\t * @param x0\n\t\t * @param y0\n\t\t * @param r0\n\t\t * @param x1\n\t\t * @param y1\n\t\t * @param r1\n\t\t * @param colorStops\n\t\t */\n\t\tsetFillRadialGradient(\n\t\t\tx0: number,\n\t\t\ty0: number,\n\t\t\tr0: number,\n\t\t\tx1: number,\n\t\t\ty1: number,\n\t\t\tr1: number,\n\t\t\tcolorStops?: ColorStop[]): TextTransaction;\n\t\t/**\n\t\t * 線の色を設定する。\n\t\t * @param color\n\t\t */\n\t\tsetStrokeColor(color: string): TextTransaction;\n\t\t/**\n\t\t * テキストを追加する。\n\t\t * @param text\n\t\t */\n\t\tpush(text: string): TextTransaction;\n\t\t/**\n\t\t * baselineを設定する。何も設定しなければ通常のベースライン。\n\t\t * @param baseline\n\t\t */\n\t\tsetBaseline(baseline?: string): TextTransaction;\n\t\t/**\n\t\t * テキストの揃えを設定する。\n\t\t * @param align\n\t\t */\n\t\tsetAlign(align?: string): TextTransaction;\n\n\t\t/**\n\t\t * フォントファミリーを設定する。\n\t\t * @param fontFamily\n\t\t */\n\t\tsetFontFamily(fontFamily: string): TextTransaction;\n\n\t\t/**\n\t\t * フォントサイズを設定する。\n\t\t * @param size\n\t\t */\n\t\tsetSize(size: number): TextTransaction;\n\n\t\t/**\n\t\t * フォント太さを設定する。\n\t\t * @param weight\n\t\t */\n\t\tsetWeight(weight: number): TextTransaction;\n\n\t\t/**\n\t\t * フォントスタイルを設定する。\n\t\t * @param style\n\t\t */\n\t\tsetStyle(style: number): TextTransaction;\n\t}\n}\nexport namespace viewer {\n\timport DrawchatRenderer = renderer.DrawchatRenderer;\n\timport DrawHistory = history.DrawHistory;\n\timport Layer = structures.Layer;\n\t/**\n\t * 編集内容と描画をリアルタイムで結びつけるクラス。\n\t */\n\texport interface DrawchatViewer {\n\n\t\t/**\n\t\t * 描画内容を全てクリアする。\n\t\t */\n\t\tclear(): void;\n\n\t\t/**\n\t\t * 画像をbase64化したデータを取得する。\n\t\t */\n\t\tcreateImageDataURI(): string;\n\n\t\t/**\n\t\t * 指定された添字のレイヤーを表示状態に設定する。\n\t\t * 引数が指定されていない場合は全件表示。\n\t\t * @param target\n\t\t */\n\t\tshow(target?: number[]): void;\n\n\t\t/**\n\t\t * 指定された添字のレイヤーを非表示状態に設定する。\n\t\t * 引数が指定されていない場合は全件非表示。\n\t\t * @param target\n\t\t */\n\t\thide(target?: number[]): void;\n\n\t\t/**\n\t\t * 指定されたピクセル座標の色成分を取得する。\n\t\t * r,g,b,aの配列を返す。\n\t\t */\n\t\tgetPixelColor(x: number, y: number, layerIndex: number): number[];\n\n\t\t/**\n\t\t * DrawchatHistoryとの同期を開始する。\n\t\t */\n\t\tstart(): void;\n\n\t\t/**\n\t\t * DrawchatHistoryとの同期を停止する。\n\t\t */\n\t\tstop(): void;\n\n\t\t/**\n\t\t * 描画内容を1から再レンダリングする。\n\t\t */\n\t\trefresh(): void;\n\t}\n\n\texport interface DrawchatViewerFactory {\n\t\tcreateInstance(\n\t\t\trenderer: DrawchatRenderer,\n\t\t\tcore?: DrawHistory): DrawchatViewer;\n\t}\n\n\texport interface NamedLayer extends Layer {\n\t\tlayerId: string;\n\t}\n\n\texport interface LayerMap {\n\t\t[key: string]: NamedLayer;\n\t}\n}\n"]}